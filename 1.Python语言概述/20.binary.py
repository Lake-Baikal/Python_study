#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @FileName  :binary.py
# @Time      :2024/03/23 17:32:51
# @Author    :Baikal
# @Motto     :我亦无他,唯手熟尔
# 进制

# 对于整数,有如下表示方法
# 1. 2进制,0,1,满2进1，以 0b或0B开头
# 2. 8进制,0~7,满8进1，以 0o或0O开头
# 3. 10进制,0~9,满10进1
# 4. 16进制,0~9,A(10)~F(15)满16进1，以 0x或0X开头，此处的A-F不区分大小写
# 2进制
print(0b111)
print(0B111)
# 8进制
print(0o111)
print(0O111)
# 16进制
print(0x111)
print(0X111)
# 10进制
print(111)
"""
!二进制转换为十进制
!规则:从最低为位(右边),将每个位上的数提取出来,乘以2的(位数-1)次方,然后求和
"""
# 请将0b1011转换为十进制
"""
1*2(1-1)次方  1
1*2(2-1)次方  2
0*2(3-1)次方  0
1*2(4-1)次方  8
1+2+0+8=11
"""
print(0b1011)
""" 
!八进制转换十进制
!规则:从最低为位(右边),将每个位上的数提取出来,乘以8的(位数-1)次方,然后求和
"""
# 请将0o234转换为十进制
""" 
4*8(1-1)次方=4
3*8(2-1)次方=24
2*8(3-1)次方=128
4+24+128=156
"""
print(0o234)
""" 
!十六进制转换十进制
!规则:从最低为位(右边),将每个位上的数提取出来,乘以16的(位数-1)次方,然后求和
"""
# 请将0x23A转换为十进制
"""
10*16(1-1)次方=10
3*16(2-1)次方=48
2*16(3-1)次方=512
10+48+512=570
"""
print(0x23A)

# 练习
# 0b110001100转换为10进制
"""
0*2(1-1) 次方0
0*2(2-1) 次方0
1*2(3-1) 次方4
1*2(4-1) 次方8
0*2(5-1) 次方0
0*2(6-1) 次方0
0*2(7-1) 次方0
1*2(8-1) 次方128
1*2(9-1) 次方256
0+0+4+8+0+0+0+128+256=396
"""
print(0b110001100)
# 0o2456转换为十进制
"""
6*8(1-1)次方=6
5*8(2-1)次方=40
4*8(3-1)次方=256
2*8(4-1)次方=1024
6+40+256+1024=1326
"""
print(0o2456)
# 0xA45转换为十进制
"""
5*16(1-1)次方=5
4*16(2-1)次方=64
10*16(3-1)次方=2560
1+64+2560=2629
"""
print(0xA45)

# 十进制转换二进制
# 将该数不断除以2，直到商为0为止，然后将每一步得到的余数倒过来，就是对应的二进制
# 34转二进制
"""
 34/2=17 余0
 17/2=8 余1
 8/2=4 余0
 4/2=2 余0
 2/2=1 余0
 1
 把余数倒过来0b100010
"""
# bin()函数可以把一个整数转换为0b开头的2进制的数
print(bin(34))

# 方法2
# 降二次幂及减法混合运算
"""
1.将以2为底数的幂函数以表格形式从右到左列出来。从2^0开始,2^0为1。指数加一递增。列表直至函数值最接近需要计算的十进制数字为止。比如说,我们现在要将十进制数字156转换为二进制。                      
512   256   128   64   32    16  8   4   2   1                                   
2^9   2^8   2^7  2^6  2^5  2^4 2^3  2^2 2^1 2^0
找出最合适的幂函数值。
2.找出小于且最接近需计算数字的幂函数值。在本例中,128是小于156的、以2为底数的幂函数值中最大的数值。所以在二进制列表128的下方写上1。然后用156减去128,得出28。
512   256   128   64   32    16  8   4   2  1   
             1                1  1   1
156-128=28
28-16=12
12-8=4
4-4=0
记住在能被差减得出正数的数字下面记录为1，不能被减的数字下面记录为0。
512   256   128   64   32    16  8   4   2  1 
              1    0    0     1  1   1   0  0
"""
# 十进制转换八进制
# 将该数不断除以8，直到商为0为止，然后将每一步得到的余数倒过来，就是对应的八进制
# 131转八进制
"""
131/8=16 余3
16/8=2 余0
2 不够除8
把余数倒过来0o203
"""
# oct()函数可以把一个整数转换为0o开头的8进制的数

print(oct(131))
# 十进制转换十六进制
# 将该数不断除以16，直到商为0为止，然后将每一步得到的余数倒过来，就是对应的十六进制
# 237转十六进制
"""
237/16=14余13
14 不够除16
十六进制中,D=13,E=14
把余数倒过来0xed
"""
# hex()函数可以把一个整数转换为0x开头的16进制的数

print(hex(237))

# 二进制转换八进制
"""
规则：从最低位开始，将二进制数每三位一组，转成对应的八进制即可
把0b11010101转成八进制
"""
# 011 010 101  不足三位补0
#  3   2    5
# 三位分组后，从左往右每一位二进制的1表示的八进制数分别是4、2、1，把二进制数为1的对应的八进制数加起来就是这一组的八进制结果咯，比如111对应了4、2、1，4+2+1就是7，再比如101对应了4、0（二进制是0，八进制就是0）、1，4+1就是5。

# 二进制转换十六进制
"""
规则：从最低位开始，将二进制数每四位一组，转成对应的十六进制即可
"""
# 0b11010101
#  1101 0101
#  D     5  =0xD5
# 四位分组后，从左往右每一位二进制的1表示的八进制数分别是8、4、2、1，把二进制数为1的对应的16进制数加起来就是这一组的16进制结果咯，比如1111对应了8、4、2、1，8+4+2+1就是15，再比如1101对应了8、4、0、1（二进制是0，16进制就是0）、8+4+1就是13对应字母d。

# 八进制转换二进制
# 规则:将八进制数每一位转换成对应的一个三位的二进制数即可
# 请将0o237转换成二进制
#  2     3      7
# 010    011   111
# 0b10011111
# 十六进制转换二进制
# 规则:将十六进制数每一位转换成对应的一个四位的二进制数即可
# 请将0x23B转换成二进制
# B在16进制中表示11
# 2       3      11
# 0010   0011   1011  =>二进制 0b1000111011
